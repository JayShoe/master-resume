#!/usr/bin/env node

import { config } from 'dotenv';
import fetch from 'node-fetch';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

// Load environment variables
config({ path: '.env.local' });

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const directusUrl = process.env.NEXT_PUBLIC_DIRECTUS_URL;
const directusToken = process.env.DIRECTUS_TOKEN;

console.log('üöÄ Fetching Directus schema...');
console.log(`üìç URL: ${directusUrl}`);
console.log(`üîë Token: ${directusToken ? '‚úÖ Provided' : '‚ùå Missing'}`);

if (!directusUrl) {
  console.error('‚ùå NEXT_PUBLIC_DIRECTUS_URL not found in .env.local');
  process.exit(1);
}

// Type mapping function
function mapDirectusTypeToTypeScript(field) {
  const { type, schema } = field;
  const isNullable = schema?.is_nullable !== false;
  
  let tsType;
  
  switch (type) {
    case 'integer':
    case 'bigInteger':
    case 'float':
    case 'decimal':
      tsType = 'number';
      break;
    case 'string':
    case 'text':
    case 'uuid':
    case 'hash':
      tsType = 'string';
      break;
    case 'boolean':
      tsType = 'boolean';
      break;
    case 'date':
    case 'dateTime':
    case 'time':
    case 'timestamp':
      tsType = 'string'; // ISO date strings
      break;
    case 'json':
      tsType = 'any';
      break;
    default:
      tsType = 'unknown';
  }
  
  return isNullable ? `${tsType} | null` : tsType;
}

// Generate interface for a collection
function generateCollectionInterface(collection, fields, relations) {
  const collectionName = collection.collection;
  const className = collectionName.charAt(0).toUpperCase() + collectionName.slice(1);
  
  // Handle singleton collections
  // className is already properly capitalized
  
  let interfaceDefinition = `export interface ${className} {\n`;
  
  // Get fields for this collection
  const collectionFields = fields.filter(f => f.collection === collectionName);
  
  for (const field of collectionFields) {
    const fieldName = field.field;
    const fieldType = mapDirectusTypeToTypeScript(field);
    const isOptional = !field.meta?.required ? '?' : '';
    const comment = field.meta?.note ? `  // ${field.meta.note}\n` : '';
    
    // Check if this field is a relation
    const relation = relations.find(r => 
      r.collection === collectionName && r.field === fieldName
    );
    
    let finalType = fieldType;
    if (relation && relation.related_collection) {
      const relatedClassName = relation.related_collection.charAt(0).toUpperCase() + 
                              relation.related_collection.slice(1);
      
      // Check relationship type
      if (relation.meta?.junction_field) {
        // Many-to-many
        finalType = `${relatedClassName}[]`;
      } else if (relation.schema?.foreign_key_column) {
        // Many-to-one
        finalType = field.meta?.required ? relatedClassName : `${relatedClassName} | null`;
      }
    }
    
    interfaceDefinition += comment;
    interfaceDefinition += `  ${fieldName}${isOptional}: ${finalType};\n`;
  }
  
  interfaceDefinition += '}\n\n';
  
  return interfaceDefinition;
}

async function fetchSchemaAndGenerateTypes() {
  try {
    const headers = directusToken ? {
      'Authorization': `Bearer ${directusToken}`
    } : {};
    
    console.log('üì° Fetching schema data...');
    
    // Fetch collections, fields, and relations in parallel
    const [collectionsRes, fieldsRes, relationsRes] = await Promise.all([
      fetch(`${directusUrl}/collections`, { headers }),
      fetch(`${directusUrl}/fields`, { headers }),
      fetch(`${directusUrl}/relations`, { headers })
    ]);
    
    if (!collectionsRes.ok || !fieldsRes.ok || !relationsRes.ok) {
      throw new Error('Failed to fetch schema data from Directus');
    }
    
    const [collectionsData, fieldsData, relationsData] = await Promise.all([
      collectionsRes.json(),
      fieldsRes.json(),
      relationsRes.json()
    ]);
    
    const collections = collectionsData.data || [];
    const fields = fieldsData.data || [];
    const relations = relationsData.data || [];
    
    console.log(`‚úÖ Fetched ${collections.length} collections, ${fields.length} fields, ${relations.length} relations`);
    
    // Filter out system collections
    const userCollections = collections.filter(col => !col.collection.startsWith('directus_'));
    
    // Generate TypeScript definitions
    let generatedTypes = `// Generated by schema-fetch command\n`;
    generatedTypes += `// DO NOT EDIT - This file is auto-generated from Directus schema\n`;
    generatedTypes += `// Generated at: ${new Date().toISOString()}\n\n`;
    
    generatedTypes += `import { createDirectus, rest, staticToken, readItems, readItem, readSingleton } from '@directus/sdk';\n\n`;
    
    // Generate interfaces
    for (const collection of userCollections) {
      const interfaceCode = generateCollectionInterface(collection, fields, relations);
      generatedTypes += interfaceCode;
    }
    
    // Generate schema interface
    let schemaInterface = 'export interface Schema {\n';
    for (const collection of userCollections) {
      const className = collection.collection.charAt(0).toUpperCase() + collection.collection.slice(1);
      const isArray = !collection.meta?.singleton;
      schemaInterface += `  ${collection.collection}: ${className}${isArray ? '[]' : ''};\n`;
    }
    schemaInterface += '}\n\n';
    generatedTypes += schemaInterface;
    
    // Generate client setup
    generatedTypes += `// Create the Directus client\n`;
    generatedTypes += `const directusUrl = process.env.NEXT_PUBLIC_DIRECTUS_URL;\n`;
    generatedTypes += `const directusToken = process.env.DIRECTUS_TOKEN;\n\n`;
    
    generatedTypes += `if (!directusUrl) {\n`;
    generatedTypes += `  throw new Error('NEXT_PUBLIC_DIRECTUS_URL is not defined in environment variables');\n`;
    generatedTypes += `}\n\n`;
    
    generatedTypes += `const baseClient = createDirectus<Schema>(directusUrl).with(rest());\n`;
    generatedTypes += `export const directus = directusToken ? baseClient.with(staticToken(directusToken)) : baseClient;\n\n`;
    
    // Generate helper functions
    generatedTypes += `// Generated helper functions\n\n`;
    
    for (const collection of userCollections) {
      const collectionName = collection.collection;
      const className = collectionName.charAt(0).toUpperCase() + collectionName.slice(1);
      const isSingleton = collection.meta?.singleton;
      
      if (isSingleton) {
        generatedTypes += `export async function get${className}() {\n`;
        generatedTypes += `  try {\n`;
        generatedTypes += `    return await directus.request(readSingleton('${collectionName}'));\n`;
        generatedTypes += `  } catch (error) {\n`;
        generatedTypes += `    console.error('Error fetching ${collectionName}:', error);\n`;
        generatedTypes += `    throw error;\n`;
        generatedTypes += `  }\n`;
        generatedTypes += `}\n\n`;
      } else {
        // Get all items
        generatedTypes += `export async function getAll${className}() {\n`;
        generatedTypes += `  try {\n`;
        generatedTypes += `    return await directus.request(readItems('${collectionName}'));\n`;
        generatedTypes += `  } catch (error) {\n`;
        generatedTypes += `    console.error('Error fetching ${collectionName}:', error);\n`;
        generatedTypes += `    throw error;\n`;
        generatedTypes += `  }\n`;
        generatedTypes += `}\n\n`;
        
        // Get by ID
        generatedTypes += `export async function get${className}ById(id: string | number) {\n`;
        generatedTypes += `  try {\n`;
        generatedTypes += `    return await directus.request(readItem('${collectionName}', id));\n`;
        generatedTypes += `  } catch (error) {\n`;
        generatedTypes += `    console.error('Error fetching ${collectionName} by id:', error);\n`;
        generatedTypes += `    throw error;\n`;
        generatedTypes += `  }\n`;
        generatedTypes += `}\n\n`;
      }
    }
    
    // Write the generated types to file
    const outputPath = path.join(__dirname, '..', 'src', 'types', 'generated-schema.ts');
    await fs.writeFile(outputPath, generatedTypes, 'utf8');
    
    console.log(`‚úÖ Generated TypeScript definitions: ${outputPath}`);
    console.log(`üìä Generated ${userCollections.length} collection interfaces`);
    
    // List the collections that were generated
    console.log('\nüìã Generated interfaces for:');
    userCollections.forEach(col => {
      const className = col.collection.charAt(0).toUpperCase() + col.collection.slice(1);
      const type = col.meta?.singleton ? 'singleton' : 'collection';
      console.log(`   ‚Ä¢ ${className} (${type})`);
    });
    
    console.log('\nüéâ Schema generation completed successfully!');
    console.log('üí° The generated types are now available in src/types/generated-schema.ts');
    console.log('üí° You can import and use them in your components');
    
  } catch (error) {
    console.error('‚ùå Schema generation failed:', error.message);
    
    if (error.code === 'ECONNREFUSED') {
      console.log('üîå Make sure your Directus instance is running and accessible');
    } else if (error.code === 'ENOTFOUND') {
      console.log('üîå Check if the Directus URL is correct');
    } else if (error.message.includes('401') || error.message.includes('403')) {
      console.log('üîê Check if your DIRECTUS_TOKEN is valid and has proper permissions');
    }
    
    process.exit(1);
  }
}

fetchSchemaAndGenerateTypes();